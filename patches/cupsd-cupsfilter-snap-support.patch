diff -uraN cups-2.3.3op2.orig/config.h.in cups-2.3.3op2/config.h.in
--- cups-2.3.3op2.orig/config.h.in	2021-03-04 14:31:42.097440563 +0100
+++ cups-2.3.3op2/config.h.in	2021-03-04 14:34:04.037989481 +0100
@@ -661,6 +661,19 @@
 #undef HAVE_SYS_STATVFS_H
 #undef HAVE_SYS_VFS_H
 
+/*
+ * Do we want Snap packaging support and have the needed libraries and
+ * utilities?
+ */
+
+#undef HAVE_APPARMOR
+#undef HAVE_SNAPDGLIB
+#undef HAVE_SNAPD_CLIENT_RUN_SNAPCTL2_SYNC
+#undef HAVE_SNAPCTL_IS_CONNECTED
+#undef SNAPCTL
+#undef CUPS_CONTROL_SLOT
+#undef SUPPORT_SNAPPED_CUPSD
+#undef SUPPORT_SNAPPED_CLIENTS
 
 /*
  * Location of macOS localization bundle, if any.
diff -uraN cups-2.3.3op2.orig/config-scripts/cups-snap.m4 cups-2.3.3op2/config-scripts/cups-snap.m4
--- cups-2.3.3op2.orig/config-scripts/cups-snap.m4	1970-01-01 01:00:00.000000000 +0100
+++ cups-2.3.3op2/config-scripts/cups-snap.m4	2021-03-04 14:34:04.037989481 +0100
@@ -0,0 +1,100 @@
+dnl
+dnl Support for packaging CUPS in a Snap and have it work with client Snaps.
+dnl
+dnl Copyright © 2021 by Till Kamppeter
+dnl Copyright © 2021 by OpenPrinting
+dnl
+dnl Licensed under Apache License v2.0.  See the file "LICENSE" for more
+dnl information.
+dnl
+
+# Snap packaging and Snap interaction support
+
+AC_ARG_ENABLE(snapped_cupsd, [  --enable-snapped-cupsd  enable support for packaging CUPS in a Snap])
+AC_ARG_ENABLE(snapped_clients, [  --enable-snapped-clients enable support for CUPS controlling admin access from snapped clients])
+AC_ARG_WITH(snapctl, [  --with-snapctl          Set path for snapctl, only needed with --enable-snapped-cupsd, default=/usr/bin/snapctl],
+        SNAPCTL="$withval", SNAPCTL="/usr/bin/snapctl")
+AC_DEFINE_UNQUOTED(SNAPCTL, "$SNAPCTL")
+AC_ARG_WITH(cups_control_slot, [  --with-cups-control-slot Name for cups-control slot as defined in snapcraft.yaml, only needed with --enable-snapped-cupsd, default=admin],
+        CUPS_CONTROL_SLOT="$withval", CUPS_CONTROL_SLOT="admin")
+AC_DEFINE_UNQUOTED(CUPS_CONTROL_SLOT, "$CUPS_CONTROL_SLOT")
+
+APPARMORLIBS=""
+SNAPDGLIBLIBS=""
+ENABLE_SNAPPED_CUPSD="NO"
+ENABLE_SNAPPED_CLIENTS="NO"
+
+# Both --enable-snapped-cupsd and --enable-snapped-clients are about additional
+# access control for clients, allowing clients which are confined Snaps only
+# to do adminstrative tasks (create queues, delete someone else's jobs, ...)
+# if they plug the "cups-control" interface, so  --enable-snapped-cupsd implies
+# --enable-snapped-clients. The difference is only the method how to determine
+# whether a client Snap is confined and plugs "cups-control".
+if test x$enable_snapped_cupsd == xyes; then
+	enable_snapped_clients=yes;
+fi
+
+if test "x$PKGCONFIG" != x -a x$enable_snapped_clients == xyes; then
+	AC_MSG_CHECKING(for libapparmor)
+	if $PKGCONFIG --exists libapparmor; then
+		AC_MSG_RESULT(yes)
+		CFLAGS="$CFLAGS `$PKGCONFIG --cflags libapparmor`"
+		APPARMORLIBS="`$PKGCONFIG --libs libapparmor`"
+		AC_DEFINE(HAVE_APPARMOR)
+		AC_MSG_CHECKING(for libsnapd-glib)
+		if $PKGCONFIG --exists snapd-glib glib-2.0 gio-2.0; then
+			AC_MSG_RESULT(yes)
+			CFLAGS="$CFLAGS `$PKGCONFIG --cflags snapd-glib glib-2.0 gio-2.0`"
+			SNAPDGLIBLIBS="`$PKGCONFIG --libs snapd-glib glib-2.0 gio-2.0`"
+			AC_DEFINE(HAVE_SNAPDGLIB)
+		else
+			AC_MSG_RESULT(no)
+		fi
+		if test x$enable_snapped_cupsd == xyes; then
+			AC_CHECK_LIB(snapd-glib, snapd_client_run_snapctl2_sync, [
+				AC_DEFINE(HAVE_SNAPD_CLIENT_RUN_SNAPCTL2_SYNC)
+				AC_DEFINE(SUPPORT_SNAPPED_CUPSD)
+				AC_DEFINE(SUPPORT_SNAPPED_CLIENTS)
+				ENABLE_SNAPPED_CUPSD="YES"
+				ENABLE_SNAPPED_CLIENTS="YES"
+			], [
+				if test "x$SNAPDGLIBLIBS" != "x"; then
+					SNAPDGLIBLIBS=""
+				fi
+				AC_PATH_TOOL(SNAPCTL, snapctl)
+				AC_MSG_CHECKING(for "snapctl is-connected" support)
+				if test "x$SNAPCTL" != x && $SNAPCTL is-connected --help >/dev/null 2>&1; then
+					AC_MSG_RESULT(yes)
+					AC_DEFINE(HAVE_SNAPCTL_IS_CONNECTED)
+					AC_DEFINE(SUPPORT_SNAPPED_CUPSD)
+					AC_DEFINE(SUPPORT_SNAPPED_CLIENTS)
+					ENABLE_SNAPPED_CUPSD="YES"
+					ENABLE_SNAPPED_CLIENTS="YES"
+				else
+					AC_MSG_RESULT(no)
+				fi
+			])
+		else
+			if test "x$SNAPDGLIBLIBS" != "x"; then
+				AC_DEFINE(SUPPORT_SNAPPED_CLIENTS)
+				ENABLE_SNAPPED_CLIENTS="YES"
+			fi
+		fi
+	else
+		AC_MSG_RESULT(no)
+	fi
+fi
+
+AC_MSG_CHECKING(for Snap support)
+if test "x$ENABLE_SNAPPED_CLIENTS" != "xNO"; then
+	if test "x$ENABLE_SNAPPED_CUPSD" != "xNO"; then
+		AC_MSG_RESULT(yes: cupsd + clients)
+	else
+		AC_MSG_RESULT(yes: clients only)
+	fi
+else
+	AC_MSG_RESULT(no)
+fi
+
+AC_SUBST(APPARMORLIBS)
+AC_SUBST(SNAPDGLIBLIBS)
diff -uraN cups-2.3.3op2.orig/configure.ac cups-2.3.3op2/configure.ac
--- cups-2.3.3op2.orig/configure.ac	2021-03-04 14:31:42.073440470 +0100
+++ cups-2.3.3op2/configure.ac	2021-03-04 14:32:06.413534495 +0100
@@ -32,6 +32,7 @@
 sinclude(config-scripts/cups-pam.m4)
 sinclude(config-scripts/cups-largefile.m4)
 sinclude(config-scripts/cups-dnssd.m4)
+sinclude(config-scripts/cups-snap.m4)
 sinclude(config-scripts/cups-startup.m4)
 sinclude(config-scripts/cups-defaults.m4)
 
diff -uraN cups-2.3.3op2.orig/Makedefs.in cups-2.3.3op2/Makedefs.in
--- cups-2.3.3op2.orig/Makedefs.in	2021-03-04 14:31:42.093440547 +0100
+++ cups-2.3.3op2/Makedefs.in	2021-03-04 14:32:06.409534480 +0100
@@ -171,6 +171,8 @@
 DNSSDLIBS	=	@DNSSDLIBS@
 IPPFIND_BIN	=	@IPPFIND_BIN@
 IPPFIND_MAN	=	@IPPFIND_MAN@
+APPARMORLIBS	=	@APPARMORLIBS@
+SNAPDGLIBLIBS	=	@SNAPDGLIBLIBS@
 LDFLAGS		=	@LDFLAGS@
 LINKCUPS	=	@LINKCUPS@
 LINKCUPSSTATIC	=	../cups/$(LIBCUPSSTATIC) $(LIBS)
diff -uraN cups-2.3.3op2.orig/scheduler/auth.c cups-2.3.3op2/scheduler/auth.c
--- cups-2.3.3op2.orig/scheduler/auth.c	2021-03-04 14:31:42.097440563 +0100
+++ cups-2.3.3op2/scheduler/auth.c	2021-03-04 14:34:04.041989498 +0100
@@ -51,6 +51,15 @@
 #  endif
 #  define CUPSD_UCRED_UID(c) (c).uid
 #endif /* HAVE_SYS_UCRED_H */
+#ifdef SUPPORT_SNAPPED_CLIENTS
+#  ifdef HAVE_APPARMOR
+#    include <sys/apparmor.h>
+#  endif
+#  ifdef HAVE_SNAPDGLIB
+#    include <glib.h>
+#    include <snapd-glib/snapd-glib.h>
+#  endif
+#endif /* SUPPORT_SNAPPED_CLIENTS */
 
 
 /*
@@ -1521,6 +1530,502 @@
 
 
 /*
+ * 'cupsdCheckAdminTask()' - Do additional checks on administrative tasks
+ */
+
+int                                      /* O - 1 if admin task authorized */
+cupsdCheckAdminTask(cupsd_client_t *con) /* I - Connection */
+{
+  int ret = 1; /* Return value */
+
+  cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdCheckAdminTask: Administrative task");
+
+ /*
+  * If the client accesses locally via domain socket, find out whether it
+  * is a Snap. Grant access if it is not a Snap, if it is a classic Snap
+  * or if it is a confined Snap which plugs "cups-control", deny access
+  * if it is a confined Snap not plugging "cups-control" or if an error
+  * occurs in the process of finding this out.
+  */
+
+#if defined(AF_LOCAL) && defined(SUPPORT_SNAPPED_CLIENTS)
+
+ /*
+  * Get the client's file descriptor and from this its AppArmor context
+  */
+
+  if (httpAddrFamily(con->http->hostaddr) == AF_LOCAL)
+  {
+    int                 peerfd;         /* Peer's file descriptor */
+
+    peerfd = httpGetFd(con->http);
+
+    if (peerfd < 0)
+    {
+      cupsdLogMessage(CUPSD_LOG_ERROR, "cupsdCheckAdminTask: Unable to get peer file descriptor of client connecting via domain socket");
+    }
+    else
+    {
+      char *context = NULL;      /* AppArmor profile name of client */
+#  undef CHECK_METHOD_FOUND
+#  ifdef SUPPORT_SNAPPED_CUPSD
+      char buf[1024];
+      int status = 65535;        /* Status of client Snap context check */
+#    if defined(HAVE_SNAPDGLIB) && defined(HAVE_SNAPD_CLIENT_RUN_SNAPCTL2_SYNC)
+#      define CHECK_METHOD_FOUND 1
+      GStrv args = NULL;
+      SnapdClient *client = NULL; /* Data structure of snapd access */
+      const char *cookie;        /* snapd access cookie */
+      GError *error = NULL;      /* Glib error */
+      gchar *stderr_output = NULL; /* Error message output of client Snap
+				      context check */
+#    else
+#      ifdef HAVE_SNAPCTL_IS_CONNECTED
+#        define CHECK_METHOD_FOUND 1
+      char *argv[5];             /* snapctl command line */
+      int fds[2],                /* Pipe file descriptors for stderr of
+				    snapctl */
+	  nullfd;                /* /dev/null file descriptor for stdout of
+				    snapctl */
+      pid_t pid;                 /* PID of snapctl */
+      cups_file_t *snapctl_stderr; /* CUPS FP for stderr of snapctl */
+      int wstatus;               /* Wait result of forked snapctl process */
+#      endif /* HAVE_SNAPCTL_IS_CONNECTED */
+#    endif /* HAVE_SNAPDGLIB && HAVE_SNAPD_CLIENT_RUN_SNAPCTL2_SYNC */
+#  else
+#    if !defined(SUPPORT_SNAPPED_CUPSD) && defined(HAVE_SNAPDGLIB)
+#      define CHECK_METHOD_FOUND 1
+      char *snap_name = NULL;    /* Client Snap name */
+      char *dot;                 /* Pointer to dot in AppArmor profile name */
+      SnapdClient *snapd = NULL; /* Data structure of snapd access */
+      GError *error = NULL;      /* Glib error */
+      SnapdSnap *snap = NULL;    /* Data structure of client Snap */
+      GPtrArray *plugs = NULL;   /* Plug search result of client Snap */
+#    endif /* !SUPPORT_SNAPPED_CUPSD && HAVE_SNAPDGLIB */
+#  endif /* SUPPORT_SNAPPED_CUPSD */
+
+
+#  ifndef SUPPORT_SNAPPED_CUPSD
+
+      /* If AppArmor is not enabled, then we can't identify the client */
+      /* With cupsd running in a Snap, the "mount-observe" interface
+         needs to be plugged, therefore we do this only if not snapped. */
+      if (!aa_is_enabled())
+      {
+	cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdCheckAdminTask: No AppArmor in use");
+	goto snap_check_done;
+      }
+
+#  endif /* !SUPPORT_SNAPPED_CUPSD */
+
+      if (aa_getpeercon(peerfd, &context, NULL) < 0)
+      {
+	cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdCheckAdminTask: AppArmor profile could not be retrieved for client process - Error: %s", strerror(errno));
+	goto snap_check_done;
+      } else
+	cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdCheckAdminTask: AppArmor profile of client process: %s", context);
+
+#  ifdef SUPPORT_SNAPPED_CUPSD
+
+     /*
+      * Run
+      *
+      * snapctl is-connected --apparmor-label=AA_CONTEXT CUPS_CONTROL_SLOT
+      *
+      * or an equivalent library function call using the
+      * snapd_client_run_snapctl2_sync() function of libsnapd-glib.
+      *
+      * Here AA_CONTEXT is the AppArmor profile name of the client, or
+      * "unconfined" for an unconfined client and CUPS_CONTROL_SLOT
+      * the name of the slot of the CUPS Snap to which clients plug
+      * with their cups-control plug in order to do administrative
+      * CUPS tasks.
+      *
+      * The exit status of the command/function call tells which type
+      * of client we have to do with:
+      *
+      *    0: The client is a confined Snap and plugs cups-control
+      *           -> Grant access
+      *    1: The client is a confined Snap and does not plug cups-control
+      *           -> Deny access
+      *   10: The client is a classic Snap
+      *           -> Grant access
+      *   11: The client is not a Snap
+      *           -> Grant access
+      *
+      * NOTE: This method only works if cupsd is running in a Snap
+      *       providing a slot for the client's "cups-control"
+      *       plug. Do not build CUPS with this method when intending
+      *       to use it unsnapped, for example in a Debian or RPM
+      *       package, or directly installed into your system. The
+      *       errors of snapctl missing or snapctl/the function
+      *       running without a Snap context will deny all
+      *       administrative accesses!
+      *
+      * When running inside a Snap this method is preferred, as it does not
+      * require full access to the snapd under which cupsd is running.
+      */
+
+      snprintf(buf, sizeof(buf), "--apparmor-label=%s", context);
+
+#    if defined(HAVE_SNAPDGLIB) && defined(HAVE_SNAPD_CLIENT_RUN_SNAPCTL2_SYNC)
+
+     /*
+      * Use the snapd_client_run_snapctl2_sync() function of libsnapd-glib
+      */
+
+      /* snapctl arguments */
+      args = g_new0 (char *, 4);
+      if (!args)
+      {
+	cupsdLogMessage(CUPSD_LOG_ERROR, "cupsdCheckAdminTask: Unable to allocate memory");
+	ret = 0;
+	goto snap_check_done;
+      }
+      args[0] = "is-connected";
+      args[1] = buf;
+      args[2] = CUPS_CONTROL_SLOT;
+      args[3] = NULL;
+
+      /* Connect to snapd */
+      client = snapd_client_new();
+      if (!client)
+      {
+	cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdCheckAdminTask: Could not connect to snapd, permission denied");
+	ret = 0;
+	goto snap_check_done;
+      }
+
+      /* snapctl commands are sent over a this socket that is made
+	 available within the snap sandbox */
+      snapd_client_set_socket_path(client, "/run/snapd-snap.socket");
+
+      /* Take context from the environment if available */
+      cookie = g_getenv("SNAP_COOKIE");
+      if (!cookie)
+      {
+        cookie = "";
+	cupsdLogMessage(CUPSD_LOG_WARN, "cupsdCheckAdminTask: No SNAP_COOKIE set in the Snap environment, permission check may not work");
+      }
+
+      /* Do the client Snap context check */
+      if (!snapd_client_run_snapctl2_sync(client, cookie, args, NULL, &stderr_output, &status, NULL, &error)) {
+	cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdCheckAdminTask: Client Snap context check error - %s", error->message);
+	ret = 0;
+	goto snap_check_done;
+      }
+
+      /* Any error message output? */
+      if (stderr_output && stderr_output[0]) {
+	cupsdLogMessage(CUPSD_LOG_ERROR, "cupsdCheckAdminTask: Error message from client Snap context check: %s", stderr_output);
+	ret = 0;
+	goto snap_check_done;
+      }
+
+#    else
+#      ifdef HAVE_SNAPCTL_IS_CONNECTED
+
+     /*
+      * Call the snapctl executable using execv() in a fork
+      */
+
+      /* snapctl command line */
+      argv[0] = SNAPCTL;
+      argv[1] = "is-connected";
+      argv[2] = buf;
+      argv[3] = CUPS_CONTROL_SLOT;
+      argv[4] = NULL;
+
+      /* Create a pipe to catch stderr output from snapctl */
+      if (pipe(fds))
+      {
+	fds[0] = -1;
+	fds[1] = -1;
+	cupsdLogMessage(CUPSD_LOG_ERROR, "cupsdCheckAdminTask: Unable to establish stderr pipe for snapctl call - %s", strerror(errno));
+	ret = 0;
+	goto snap_check_done;
+      }
+
+      /* Set the "close on exec" flag on each end of the pipe... */
+      if (fcntl(fds[0], F_SETFD, fcntl(fds[0], F_GETFD) | FD_CLOEXEC))
+      {
+	close(fds[0]);
+	close(fds[1]);
+	fds[0] = -1;
+	fds[1] = -1;
+	cupsdLogMessage(CUPSD_LOG_ERROR, "cupsdCheckAdminTask: Unable to set \"close on exec\" flag on read end of the stderr pipe for snapctl call - %s", strerror(errno));
+	ret = 0;
+	goto snap_check_done;
+      }
+      if (fcntl(fds[1], F_SETFD, fcntl(fds[1], F_GETFD) | FD_CLOEXEC))
+      {
+	close(fds[0]);
+	close(fds[1]);
+	cupsdLogMessage(CUPSD_LOG_ERROR, "cupsdCheckAdminTask: Unable to set \"close on exec\" flag on write end of the stderr pipe for snapctl call - %s", strerror(errno));
+	ret = 0;
+	goto snap_check_done;
+      }
+
+      if ((pid = fork()) == 0)
+      {
+	/* Couple pipe with stderr of Ghostscript process */
+	if (fds[1] >= 0) {
+	  if (fds[1] != 2) {
+	    if (dup2(fds[1], 2) < 0) {
+	      cupsdLogMessage(CUPSD_LOG_ERROR, "cupsdCheckAdminTask: Unable to couple pipe with stderr of snapctl process - %s", strerror(errno));
+	      exit(100);
+	    }
+	    close(fds[1]);
+	  }
+	  close(fds[0]);
+	} else {
+	  cupsdLogMessage(CUPSD_LOG_ERROR, "cupsdCheckAdminTask: Invalid pipe file descriptor to couple with stderr of snapctl process - %s", strerror(errno));
+	  exit(100);
+	}
+
+	/* Send snapctl's stdout to the Nirwana, as snapctl is supposed to
+	   not output anything here */
+	if ((nullfd = open("/dev/null", O_RDWR)) > 2)
+	{
+	  dup2(nullfd, 1);
+	  close(nullfd);
+	}
+	else
+	  close(nullfd);
+	fcntl(1, F_SETFL, O_NDELAY);
+
+	/* Execute snapctl command line ... */
+	cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdCheckAdminTask: Running command: " SNAPCTL " is-connected %s " CUPS_CONTROL_SLOT, buf);
+	execv(SNAPCTL, argv);
+	cupsdLogMessage(CUPSD_LOG_ERROR, "cupsdCheckAdminTask: Unable to launch snapctl: %s", strerror(errno));
+	exit(100);
+      }
+      else if (pid < 0)
+      {
+	cupsdLogMessage(CUPSD_LOG_ERROR, "cupsdCheckAdminTask: Unable to fork for snapctl call - %s", strerror(errno));
+	ret = 0;
+	goto snap_check_done;
+      }
+      cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdCheckAdminTask: Started snapctl (PID %d)", pid);
+
+      close(fds[1]);
+
+      /* Read out stderr from snapctl */
+      buf[0] = '\0';
+      snapctl_stderr = cupsFileOpenFd(fds[0], "r");
+      if (snapctl_stderr)
+      {
+	while (cupsFileGets(snapctl_stderr, buf, sizeof(buf)) && buf[0])
+	{
+	  cupsdLogMessage(CUPSD_LOG_ERROR, "cupsdCheckAdminTask: Error message from snapctl: %s", buf);
+	  ret = 0;
+	}
+	cupsFileClose(snapctl_stderr);
+      }
+      close(fds[0]);
+
+      /* Wait for snapctl to finish */
+    retry_wait:
+      if (waitpid (pid, &wstatus, 0) == -1)
+      {
+	if (errno == EINTR)
+	  goto retry_wait;
+	cupsdLogMessage(CUPSD_LOG_ERROR, "cupsdCheckAdminTask: snapctl (PID %d) stopped with an error - %s", pid, strerror(errno));
+	ret = 0;
+	goto snap_check_done;
+      }
+      if (ret == 0)
+	goto snap_check_done;
+      cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdCheckAdminTask: snapctl (PID %d) exited with no errors.", pid);
+
+      /* How did snapctl terminate */
+      if (WIFEXITED(wstatus))
+      {
+	/* Via regular exit */
+	status = WEXITSTATUS(wstatus);
+	if (status == 100)
+	{
+	  cupsdLogMessage(CUPSD_LOG_ERROR, "cupsdCheckAdminTask: snapctl not executed");
+	  ret = 0;
+	  goto snap_check_done;
+	}
+      }
+      else if (WIFSIGNALED(wstatus))
+      {
+	/* Via signal */
+	cupsdLogMessage(CUPSD_LOG_ERROR, "cupsdCheckAdminTask: snapctl caught the signal %d", WTERMSIG(wstatus));
+	ret = 0;
+	goto snap_check_done;
+      }
+
+#      endif /* HAVE_SNAPCTL_IS_CONNECTED */
+#    endif /* HAVE_SNAPDGLIB && HAVE_SNAPD_CLIENT_RUN_SNAPCTL2_SYNC */
+
+      if (status == 0)
+	cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdCheckAdminTask: Client Snap connecting via \"cups-control\" interface, access granted");
+      else if (status == 1)
+      {
+	cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdCheckAdminTask: Client Snap does not connect via \"cups-control\" interface, permission denied");
+	ret = 0;
+      }
+      else if (status == 10)
+	cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdCheckAdminTask: Client Snap under classic confinement, access granted");
+      else if (status == 11)
+	cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdCheckAdminTask: Client is not a Snap, access granted");
+      else
+      {
+	cupsdLogMessage(CUPSD_LOG_ERROR, "cupsdCheckAdminTask: snapctl exited with unknown status: %d", status);
+	ret = 0;
+      }
+
+    snap_check_done:
+      if (context)
+	free(context);
+#    if defined(HAVE_SNAPDGLIB) && defined(HAVE_SNAPD_CLIENT_RUN_SNAPCTL2_SYNC)
+      if (client)
+	g_clear_object(&client);
+      if (args)
+	g_free(args);
+      if (stderr_output)
+	g_free(stderr_output);
+#    endif /* HAVE_SNAPDGLIB && HAVE_SNAPD_CLIENT_RUN_SNAPCTL2_SYNC */
+
+#  else
+#    if !defined(SUPPORT_SNAPPED_CUPSD) && defined(HAVE_SNAPDGLIB)
+
+     /*
+      * If the client is a Snap, extract the client Snap's name from
+      * the AppArmor context and then query snapd to find out about the
+      * Snap's confinement type and whether it plugs cups-control. Grant
+      * access if
+      *
+      *   - the client is not a Snap
+      *   - the client is a classic Snap
+      *   - the client is a confined Snap plugging "cups-control"
+      *
+      * We deny access if
+      *
+      *   - the client is a confined Snap not plugging "cups-control"
+      *   - an error occurs during the steps of this method
+      *
+      * NOTE: This method is only for use of cupsd when it is not
+      *       packaged in a Snap. In a Snap one would need to plug the
+      *       snapd-control interface, which gives full control on
+      *       snapd, a high security risk. Therefore one will not get
+      *       automatic connection of this interface granted in the
+      *       Snap Store. This is the reason why the snapctl method
+      *       (above) got created by the snapd developers.
+      *
+      * This is the preferred method to run CUPS unsnapped, as this is
+      * the only way to check Snap status on clients from an unsnapped
+      * cupsd.
+      */
+
+      /* If the AppArmor context does not begin with "snap.", then this
+         is not a snap */
+      if (strncmp(context, "snap.", 5) != 0)
+      {
+	cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdCheckAdminTask: AppArmor context not from a Snap");
+        goto snap_check_done;
+      }
+
+      dot = strchr(context + 5, '.');
+      if (dot == NULL)
+      {
+        cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdCheckAdminTask: Malformed snapd AppArmor profile name: %s", context);
+        goto snap_check_done;
+      }
+      snap_name = strndup(context + 5, (size_t)(dot - context - 5));
+      cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdCheckAdminTask: Client is the Snap %s", snap_name);
+
+      /* Connect to snapd */
+      snapd = snapd_client_new();
+      if (!snapd)
+      {
+	cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdCheckAdminTask: Could not connect to snapd, permission denied");
+	ret = 0;
+	goto snap_check_done;
+      }
+
+      /* Check whether the client Snap is under classic confinement */
+      snap = snapd_client_get_snap_sync(snapd, snap_name, NULL, &error);
+      if (!snap)
+      {
+        cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdCheckAdminTask: Could not obtain client Snap data: \"%s\", permission denied", error->message);
+	ret = 0;
+	goto snap_check_done;
+      }
+
+      /* Snaps using classic confinement are granted access */
+      if (snapd_snap_get_confinement(snap) == SNAPD_CONFINEMENT_CLASSIC)
+      {
+        cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdCheckAdminTask: Client Snap under classic confinement, access granted");
+        goto snap_check_done;
+      }
+
+      /* Get list of interfaces to which the client Snap is plugging */
+      if (!snapd_client_get_connections2_sync(snapd, SNAPD_GET_CONNECTIONS_FLAGS_NONE, snap_name, "cups-control", NULL, NULL, &plugs, NULL, NULL, &error))
+      {
+        cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdCheckAdminTask: Could not obtain the client Snap's interface connections: \"%s\", permission denied", error->message);
+	ret = 0;
+	goto snap_check_done;
+      }
+
+      if (plugs->len <= 0)
+      {
+	cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdCheckAdminTask: Client Snap does not connect via \"cups-control\" interface, permission denied");
+	ret = 0;
+	goto snap_check_done;
+      }
+
+      cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdCheckAdminTask: Client Snap connecting via \"cups-control\" interface, access granted");
+
+    snap_check_done:
+      if (context)
+	free(context);
+      if (snap_name)
+	free(snap_name);
+      if (snapd)
+	g_clear_object(&snapd);
+      if (snap)
+	g_clear_object(&snap);
+      if (plugs)
+	g_clear_object(&plugs);
+
+#    endif /* !SUPPORT_SNAPPED_CUPSD && HAVE_SNAPDGLIB */
+#  endif /* SUPPORT_SNAPPED_CUPSD */
+
+#  ifndef CHECK_METHOD_FOUND
+
+     /*
+      * Issue warning if requirements for building Snap-related access control
+      * not fulfilled
+      */
+
+      cupsdLogMessage(CUPSD_LOG_WARN, "cupsdCheckAdminTask: Compiling problem: none of the three access control methods (libsnapd-glib snapd access, \"snapctl is-connected\", libsnapd-glib-based snapctl call) available, no Snap-related access control built!");
+
+    snap_check_done:
+      if (context)
+	free(context);
+
+#  endif /* !CHECK_METHOD_FOUND */
+
+    }
+  }
+
+  cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdCheckAdminTask: Access %s", ret == 1 ? "granted" : "denied");
+
+#else
+
+  cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdCheckAdminTask: Access granted (no extra checking)");
+
+#endif /* AF_LOCAL && SUPPORT_SNAPPED_CLIENTS */
+
+  return ret;
+}
+
+
+/*
  * 'cupsdIsAuthorized()' - Check to see if the user is authorized...
  */
 
@@ -1714,12 +2219,9 @@
 
  /*
   * OK, got a username.  See if we need normal user access, or group
-  * access... (root always matches)
+  * access...
   */
 
-  if (!strcmp(username, "root"))
-    return (HTTP_OK);
-
  /*
   * Strip any @domain or @KDC from the username and owner...
   */
@@ -1749,6 +2251,21 @@
   else
     pw = NULL;
 
+ /*
+  * For matching user and group memberships below we will first go
+  * through all names except @SYSTEM to authorize the task as
+  * non-administrative, like printing or deleting one's own job, if this
+  * fails we will check whether we can authorize via the special name
+  * @SYSTEM, as an administrative task, like creating a print queue or
+  * deleting someone else's job.
+  * Note that tasks are considered as administrative by the policies
+  * in cupsd.conf, when they require the user or group @SYSTEM.
+  * We do this separation because if the client is a Snap connecting via
+  * domain socket, we need to additionally check whether it plugs to us
+  * through the "cups-control" interface which allows administration and
+  * not through the "cups" interface which allows only printing.
+  */
+
   if (best->level == CUPSD_AUTH_USER)
   {
    /*
@@ -1779,8 +2296,15 @@
       {
 	if (!_cups_strncasecmp(name, "@AUTHKEY(", 9) && check_authref(con, name + 9))
 	  return (HTTP_OK);
-	else if (!_cups_strcasecmp(name, "@SYSTEM") && SystemGroupAuthKey &&
-		 check_authref(con, SystemGroupAuthKey))
+      }
+
+      for (name = (char *)cupsArrayFirst(best->names);
+           name;
+	   name = (char *)cupsArrayNext(best->names))
+      {
+	if (!_cups_strcasecmp(name, "@SYSTEM") && SystemGroupAuthKey &&
+	    check_authref(con, SystemGroupAuthKey) &&
+	    cupsdCheckAdminTask(con))
 	  return (HTTP_OK);
       }
 
@@ -1797,9 +2321,8 @@
 	return (HTTP_OK);
       else if (!_cups_strcasecmp(name, "@SYSTEM"))
       {
-        for (i = 0; i < NumSystemGroups; i ++)
-	  if (cupsdCheckGroup(username, pw, SystemGroups[i]))
-	    return (HTTP_OK);
+	/* Do @SYSTEM later, when every other entry fails */
+	continue;
       }
       else if (name[0] == '@')
       {
@@ -1810,6 +2333,19 @@
         return (HTTP_OK);
     }
 
+    for (name = (char *)cupsArrayFirst(best->names);
+	 name;
+	 name = (char *)cupsArrayNext(best->names))
+    {
+      if (!_cups_strcasecmp(name, "@SYSTEM"))
+      {
+        for (i = 0; i < NumSystemGroups; i ++)
+	  if (cupsdCheckGroup(username, pw, SystemGroups[i]) &&
+	      cupsdCheckAdminTask(con))
+	    return (HTTP_OK);
+      }
+    }
+
     return (con->username[0] ? HTTP_FORBIDDEN : HTTP_UNAUTHORIZED);
   }
 
@@ -1827,16 +2363,31 @@
        name;
        name = (char *)cupsArrayNext(best->names))
   {
+    if (!_cups_strcasecmp(name, "@SYSTEM"))
+    {
+      /* Do @SYSTEM later, when every other entry fails */
+      continue;
+    }
+
     cupsdLogMessage(CUPSD_LOG_DEBUG2, "cupsdIsAuthorized: Checking group \"%s\" membership...", name);
 
+    if (cupsdCheckGroup(username, pw, name))
+      return (HTTP_OK);
+  }
+
+  for (name = (char *)cupsArrayFirst(best->names);
+       name;
+       name = (char *)cupsArrayNext(best->names))
+  {
     if (!_cups_strcasecmp(name, "@SYSTEM"))
     {
+      cupsdLogMessage(CUPSD_LOG_DEBUG2, "cupsdIsAuthorized: Checking group \"%s\" membership...", name);
+
       for (i = 0; i < NumSystemGroups; i ++)
-	if (cupsdCheckGroup(username, pw, SystemGroups[i]))
+	if (cupsdCheckGroup(username, pw, SystemGroups[i]) &&
+	    cupsdCheckAdminTask(con))
 	  return (HTTP_OK);
     }
-    else if (cupsdCheckGroup(username, pw, name))
-      return (HTTP_OK);
   }
 
  /*
diff -uraN cups-2.3.3op2.orig/scheduler/cert.c cups-2.3.3op2/scheduler/cert.c
--- cups-2.3.3op2.orig/scheduler/cert.c	2021-03-04 14:31:42.097440563 +0100
+++ cups-2.3.3op2/scheduler/cert.c	2021-03-04 14:32:11.273553276 +0100
@@ -83,7 +83,7 @@
 
   if (pid == 0)
   {
-#ifdef HAVE_ACL_INIT
+#if defined(HAVE_ACL_INIT) && !defined(SUPPORT_SNAPPED_CUPSD)
     acl_t		acl;		/* ACL information */
     acl_entry_t		entry;		/* ACL entry */
     acl_permset_t	permset;	/* Permissions */
@@ -92,7 +92,7 @@
 #  endif /* HAVE_MBR_UID_TO_UUID */
     static int		acls_not_supported = 0;
 					/* Only warn once */
-#endif /* HAVE_ACL_INIT */
+#endif /* HAVE_ACL_INIT && !SUPPORT_SNAPPED_CUPSD */
 
 
    /*
@@ -100,11 +100,18 @@
     */
 
     fchmod(fd, 0440);
+
+    /* ACLs do not work when cupsd is running in a Snap, and certificates
+       need root as group owner to be only accessible for CUPS and not the
+       unprivileged sub-processes */
+#ifdef SUPPORT_SNAPPED_CUPSD
+    fchown(fd, RunUser, 0);
+#else
     fchown(fd, RunUser, SystemGroupIDs[0]);
 
     cupsdLogMessage(CUPSD_LOG_DEBUG2, "cupsdAddCert: NumSystemGroups=%d", NumSystemGroups);
 
-#ifdef HAVE_ACL_INIT
+#  ifdef HAVE_ACL_INIT
     if (NumSystemGroups > 1)
     {
      /*
@@ -114,7 +121,7 @@
 
       int	j;			/* Looping var */
 
-#  ifdef HAVE_MBR_UID_TO_UUID
+#    ifdef HAVE_MBR_UID_TO_UUID
      /*
       * On macOS, ACLs use UUIDs instead of GIDs...
       */
@@ -143,7 +150,7 @@
 	acl_set_permset(entry, permset);
       }
 
-#  else
+#    else
      /*
       * POSIX ACLs need permissions for owner, group, other, and mask
       * in addition to the rest of the system groups...
@@ -215,7 +222,7 @@
 	cupsdLogMessage(CUPSD_LOG_ERROR, "ACL: %s", text);
 	acl_free(text);
       }
-#  endif /* HAVE_MBR_UID_TO_UUID */
+#    endif /* HAVE_MBR_UID_TO_UUID */
 
       if (acl_set_fd(fd, acl))
       {
@@ -230,7 +237,8 @@
 
       acl_free(acl);
     }
-#endif /* HAVE_ACL_INIT */
+#  endif /* HAVE_ACL_INIT */
+#endif /* SUPPORT_SNAPPED_CUPSD */
 
     RootCertTime = time(NULL);
   }
diff -uraN cups-2.3.3op2.orig/scheduler/conf.c cups-2.3.3op2/scheduler/conf.c
--- cups-2.3.3op2.orig/scheduler/conf.c	2021-03-04 14:31:42.097440563 +0100
+++ cups-2.3.3op2/scheduler/conf.c	2021-03-04 14:32:11.273553276 +0100
@@ -1132,8 +1132,16 @@
 			     Group, 1, 1) < 0 ||
        cupsdCheckPermissions(StateDir, NULL, 0755, RunUser,
 			     Group, 1, 1) < 0 ||
+       /* Inside a Snap cupsd is running as root without CAP_DAC_OVERRIDE
+	  capability, so certs directory has to be root.root-owned so that
+	  cupsd can access but not its unprivileged sub-processes. */
+#ifdef SUPPORT_SNAPPED_CUPSD
+       cupsdCheckPermissions(StateDir, "certs", 0711, RunUser,
+			     0, 1, 1) < 0 ||
+#else
        cupsdCheckPermissions(StateDir, "certs", RunUser ? 0711 : 0511, User,
 			     SystemGroupIDs[0], 1, 1) < 0 ||
+#endif /* SUPPORT_SNAPPED_CUPSD */
        cupsdCheckPermissions(ServerRoot, NULL, 0755, RunUser,
 			     Group, 1, 0) < 0 ||
        cupsdCheckPermissions(ServerRoot, "ppd", 0755, RunUser,
diff -uraN cups-2.3.3op2.orig/scheduler/cupsfilter.c cups-2.3.3op2/scheduler/cupsfilter.c
--- cups-2.3.3op2.orig/scheduler/cupsfilter.c	2021-03-04 14:31:42.097440563 +0100
+++ cups-2.3.3op2/scheduler/cupsfilter.c	2021-03-04 14:32:11.273553276 +0100
@@ -921,7 +921,11 @@
 {
   int		i;			/* Looping var */
   const char	*argv[8],		/* Command-line arguments */
+#ifdef SUPPORT_SNAPPED_CUPSD
+		*envp[21],		/* Environment variables */
+#else
 		*envp[17],		/* Environment variables */
+#endif /* SUPPORT_SNAPPED_CUPSD */
 		*temp;			/* Temporary string */
   char		*optstr,		/* Filter options */
 		content_type[1024],	/* CONTENT_TYPE */
@@ -929,9 +933,17 @@
 		cups_fontpath[1024],	/* CUPS_FONTPATH */
 		cups_serverbin[1024],	/* CUPS_SERVERBIN */
 		cups_serverroot[1024],	/* CUPS_SERVERROOT */
+#ifdef SUPPORT_SNAPPED_CUPSD
+		fontconfig_file[1024],	/* FONTCONFIG_FILE */
+		fontconfig_path[1024],	/* FONTCONFIG_PATH */
+		fontconfig_sysroot[1024], /* FONTCONFIG_SYSROOT */
+#endif /* SUPPORT_SNAPPED_CUPSD */
 		final_content_type[1024] = "",
 					/* FINAL_CONTENT_TYPE */
 		lang[1024],		/* LANG */
+#ifdef SUPPORT_SNAPPED_CUPSD
+		ld_library_path[2048],	/* LD_LIBRARY_PATH */
+#endif /* SUPPORT_SNAPPED_CUPSD */
 		path[1024],		/* PATH */
 		ppd[1024],		/* PPD */
 		printer_info[255],	/* PRINTER_INFO env variable */
@@ -990,6 +1002,9 @@
   * Setup the filter environment and command-line...
   */
 
+  /* If we are running confined in a Snap, also pass on fontconfig-related
+     environment variables and LD_LIBRARY_PATH */
+
   optstr = escape_options(num_options, options);
 
   snprintf(content_type, sizeof(content_type), "CONTENT_TYPE=%s/%s",
@@ -1000,8 +1015,20 @@
            ServerBin);
   snprintf(cups_serverroot, sizeof(cups_serverroot), "CUPS_SERVERROOT=%s",
            ServerRoot);
+#ifdef SUPPORT_SNAPPED_CUPSD
+  snprintf(fontconfig_file, sizeof(fontconfig_file), "FONTCONFIG_FILE=%s",
+           getenv("FONTCONFIG_FILE"));
+  snprintf(fontconfig_path, sizeof(fontconfig_path), "FONTCONFIG_PATH=%s",
+           getenv("FONTCONFIG_PATH"));
+  snprintf(fontconfig_sysroot, sizeof(fontconfig_sysroot),
+	   "FONTCONFIG_SYSROOT=%s", getenv("FONTCONFIG_SYSROOT"));
+#endif /* SUPPORT_SNAPPED_CUPSD */
   language = cupsLangDefault();
   snprintf(lang, sizeof(lang), "LANG=%s.UTF8", language->language);
+#ifdef SUPPORT_SNAPPED_CUPSD
+  snprintf(ld_library_path, sizeof(ld_library_path), "LD_LIBRARY_PATH=%s",
+	   getenv("LD_LIBRARY_PATH"));
+#endif /* SUPPORT_SNAPPED_CUPSD */
   snprintf(path, sizeof(path), "PATH=%s", Path);
   if (ppdfile)
     snprintf(ppd, sizeof(ppd), "PPD=%s", ppdfile);
@@ -1073,6 +1100,26 @@
   envp[5]  = cups_serverroot;
   envp[6]  = lang;
   envp[7]  = path;
+#ifdef SUPPORT_SNAPPED_CUPSD
+  envp[8]  = ld_library_path;
+  envp[9]  = ppd;
+  envp[10] = printer_info;
+  envp[11] = printer_location;
+  envp[12] = printer_name;
+  envp[13] = rip_max_cache;
+  envp[14] = userenv;
+  envp[15] = "CHARSET=utf-8";
+  envp[16] = fontconfig_file;
+  envp[17] = fontconfig_path;
+  envp[18] = fontconfig_sysroot;
+  if (final_content_type[0])
+  {
+    envp[19] = final_content_type;
+    envp[20] = NULL;
+  }
+  else
+    envp[19] = NULL;
+#else
   envp[8]  = ppd;
   envp[9]  = printer_info;
   envp[10] = printer_location;
@@ -1087,6 +1134,7 @@
   }
   else
     envp[15] = NULL;
+#endif /* SUPPORT_SNAPPED_CUPSD */
 
   for (i = 0; argv[i]; i ++)
     fprintf(stderr, "DEBUG: argv[%d]=\"%s\"\n", i, argv[i]);
@@ -1418,7 +1466,14 @@
     cupsFileClose(fp);
   }
 
+  /* Set the PATH environment variable for external executables, pass
+     through the PATH from the environment in which cupsd was called
+     if we are running confined in a Snap */
+#ifdef SUPPORT_SNAPPED_CUPSD
+  snprintf(line, sizeof(line), "%s/filter:%s:" CUPS_BINDIR ":" CUPS_SBINDIR ":/bin:/usr/bin", ServerBin, getenv("PATH"));
+#else
   snprintf(line, sizeof(line), "%s/filter:" CUPS_BINDIR ":" CUPS_SBINDIR ":/bin:/usr/bin", ServerBin);
+#endif /* SUPPORT_SNAPPED_CUPSD */
   set_string(&Path, line);
 
   return (0);
diff -uraN cups-2.3.3op2.orig/scheduler/env.c cups-2.3.3op2/scheduler/env.c
--- cups-2.3.3op2.orig/scheduler/env.c	2021-03-04 14:31:42.097440563 +0100
+++ cups-2.3.3op2/scheduler/env.c	2021-03-04 14:32:11.273553276 +0100
@@ -114,11 +114,14 @@
     return;
 
  /*
-  * Do not allow dynamic linker variables when running as root...
+  * Do not allow dynamic linker variables when running as root and
+  * not being confined in a Snap...
   */
 
+#ifndef SUPPORT_SNAPPED_CUPSD
   if (!RunUser && (!strncmp(name, "DYLD_", 5) || !strncmp(name, "LD_", 3)))
     return;
+#endif /* !SUPPORT_SNAPPED_CUPSD */
 
  /*
   * See if this variable has already been defined...
@@ -208,9 +211,19 @@
   set_if_undefined("LD_LIBRARY_PATH", NULL);
   set_if_undefined("LD_PRELOAD", NULL);
   set_if_undefined("NLSPATH", NULL);
+  /* Only if cupsd is confined in a Snap we pass the PATH environment
+     variable on for external executables we call */
   if (find_env("PATH") < 0)
-    cupsdSetEnvf("PATH", "%s/filter:" CUPS_BINDIR ":" CUPS_SBINDIR
-			 ":/bin:/usr/bin", ServerBin);
+  {
+#ifdef SUPPORT_SNAPPED_CUPSD
+    char *value;
+    if ((value = getenv("PATH")) != NULL)
+      cupsdSetEnvf("PATH", "%s/filter:%s", ServerBin, value);
+    else
+#endif /* SUPPORT_SNAPPED_CUPSD */
+      cupsdSetEnvf("PATH", "%s/filter:" CUPS_BINDIR ":" CUPS_SBINDIR
+		   ":/bin:/usr/bin", ServerBin);
+  }
   set_if_undefined("SERVER_ADMIN", ServerAdmin);
   set_if_undefined("SHLIB_PATH", NULL);
   set_if_undefined("SOFTWARE", CUPS_MINIMAL);
diff -uraN cups-2.3.3op2.orig/scheduler/Makefile cups-2.3.3op2/scheduler/Makefile
--- cups-2.3.3op2.orig/scheduler/Makefile	2021-03-04 14:31:42.097440563 +0100
+++ cups-2.3.3op2/scheduler/Makefile	2021-03-04 14:32:06.413534495 +0100
@@ -318,13 +318,15 @@
 	echo Linking $@...
 	$(LD_CC) $(ALL_LDFLAGS) -o cupsd $(CUPSDOBJS) libcupsmime.a \
 		$(PAMLIBS) $(LIBPAPER) $(LIBMALLOC) $(DNSSDLIBS) $(SERVERLIBS) \
-		$(ONDEMANDLIBS) $(LIBWRAP) $(LIBGSSAPI) $(COMMONLIBS) $(LINKCUPS)
+		$(ONDEMANDLIBS) $(LIBWRAP) $(LIBGSSAPI) $(COMMONLIBS) $(LINKCUPS) \
+		$(APPARMORLIBS) $(SNAPDGLIBLIBS)
 	$(CODE_SIGN) -s "$(CODE_SIGN_IDENTITY)" $@
 
 cupsd-static:	$(CUPSDOBJS) libcupsmime.a ../cups/$(LIBCUPSSTATIC)
 	echo Linking $@...
 	$(LD_CC) $(ALL_LDFLAGS) -o cupsd-static $(CUPSDOBJS) libcupsmime.a \
-		$(PAMLIBS) $(LIBPAPER) $(LIBMALLOC) $(SERVERLIBS) $(ONDEMANDLIBS) \ $(LIBWRAP) $(LINKCUPSSTATIC)
+		$(PAMLIBS) $(LIBPAPER) $(LIBMALLOC) $(SERVERLIBS) $(ONDEMANDLIBS) \
+		$(LIBWRAP) $(APPARMORLIBS) $(SNAPDGLIBLIBS) $(LINKCUPSSTATIC)
 	$(CODE_SIGN) -s "$(CODE_SIGN_IDENTITY)" $@
 
 
